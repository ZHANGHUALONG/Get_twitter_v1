æˆ‘çš„æºä»£ç ç°åœ¨æœ‰ä¸€ä¸ªå°é—®é¢˜ï¼Œä¸€æ˜¯åˆ›å»ºæ—¶é—´çš„æ—¶å·®é—®é¢˜ï¼Œåº”è¯¥æŠŠAPIæ¨é€çš„æ—¶é—´è½¬æ¢ä¸ºåŒ—äº¬æ—¶é—´ï¼ŒäºŒæ˜¯äº’åŠ¨æ•°æ®ç­‰åº”è¯¥ä¿å­˜åœ¨æ•°æ®åº“ä¸­çš„å†…å®¹å…¨éƒ¨éƒ½ä¸º0æˆ–è€…nullï¼Œä½†æ˜¯ä»ç»ˆç«¯è¾“å‡ºçš„ç»“æœæ¥çœ‹ï¼Œå‰ç«¯è¾“å‡ºæ‹¿åˆ°äº†æ­£ç¡®çš„æ•°æ®ï¼Œè¯·ç»“åˆè¿™ä¸ªæƒ…å†µå¯¹æœ‰é—®é¢˜çš„æºç éƒ¨åˆ†è¿›è¡Œå®Œå–„ï¼šai_summarizer.pyï¼š

import os
import json
from openai import OpenAI
from dotenv import load_dotenv


class AISummarizer:
    def __init__(self):
        # åŠ è½½ç¯å¢ƒå˜é‡
        load_dotenv()

        # è·å–é˜¿é‡Œäº‘ç™¾ç‚¼APIå¯†é’¥
        self.api_key = os.getenv('DASHSCOPE_API_KEY')
        if not self.api_key:
            raise ValueError("è¯·åœ¨.envæ–‡ä»¶ä¸­é…ç½®DASHSCOPE_API_KEY")

        # åˆå§‹åŒ–é˜¿é‡Œäº‘ç™¾ç‚¼å®¢æˆ·ç«¯
        self.client = OpenAI(
            api_key=self.api_key,
            base_url="https://dashscope.aliyuncs.com/compatible-mode/v1",  # åŒ—äº¬åœ°åŸŸ
        )

        # è®¾ç½®æ¨¡å‹
        self.model = "qwen-plus"  # å¯æ ¹æ®éœ€è¦æ”¹ä¸º qwen-max æˆ– qwen-flash

    def generate_summary(self, formatted_tweet):
        """
        ä½¿ç”¨é˜¿é‡Œäº‘ç™¾ç‚¼å¤§æ¨¡å‹ç”Ÿæˆæ¨æ–‡æ‘˜è¦

        Args:
            formatted_tweet: æ ¼å¼åŒ–åçš„æ¨æ–‡æ•°æ®

        Returns:
            str: ç”Ÿæˆçš„æ‘˜è¦æ–‡æœ¬
        """
        try:
            # æ„å»ºæ¨æ–‡å†…å®¹
            tweet_content = formatted_tweet.get('text', '')
            username = formatted_tweet.get('username', '')
            metrics = formatted_tweet.get('public_metrics', {})

            # æ„å»ºæç¤ºè¯
            prompt = f"""
è¯·å¯¹ä»¥ä¸‹æ¨æ–‡å†…å®¹è¿›è¡Œæ‘˜è¦åˆ†æï¼š

å‘å¸ƒè€…: @{username}
æ¨æ–‡å†…å®¹: {tweet_content}
äº’åŠ¨æ•°æ®: ç‚¹èµ{metrics.get('like_count', 0)} | è½¬æ¨{metrics.get('retweet_count', 0)} | å›å¤{metrics.get('reply_count', 0)}

è¯·ä»ä»¥ä¸‹è§’åº¦ç”Ÿæˆä¸€ä¸ªç®€æ´çš„æ‘˜è¦ï¼š
1. ä¸»è¦å†…å®¹æ¦‚æ‹¬
2. æƒ…æ„Ÿå€¾å‘åˆ†æ
3. å¯èƒ½çš„è¯é¢˜æ ‡ç­¾å»ºè®®
4. ç›¸å…³è¯é¢˜çƒ­åº¦æƒ…å†µ

è¦æ±‚ï¼šå›å¤å†…å®¹ä¸ºçº¯æ–‡æœ¬ï¼Œä¸è¶…è¿‡150å­—ã€‚
"""

            # è°ƒç”¨é˜¿é‡Œäº‘ç™¾ç‚¼API
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç¤¾äº¤åª’ä½“å†…å®¹åˆ†æå¸ˆï¼Œæ“…é•¿ç”¨ç®€æ´çš„è¯­è¨€æ¦‚æ‹¬æ¨æ–‡å†…å®¹ã€‚"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,  # è¾ƒä½çš„æ¸©åº¦å€¼ä»¥è·å¾—æ›´ç¨³å®šçš„è¾“å‡º
                max_tokens=300  # é™åˆ¶è¾“å‡ºé•¿åº¦
            )

            # æå–ç”Ÿæˆçš„æ‘˜è¦
            summary = response.choices[0].message.content.strip()
            return summary

        except Exception as e:
            print(f"AIæ‘˜è¦ç”Ÿæˆå¤±è´¥: {e}")
            return f"æ‘˜è¦ç”Ÿæˆå¤±è´¥: {str(e)}"

    def batch_summarize(self, tweets_list):
        """
        æ‰¹é‡ç”Ÿæˆæ¨æ–‡æ‘˜è¦ (ä¿ç•™æ­¤æ–¹æ³•ç”¨äºå…¼å®¹æ€§)

        Args:
            tweets_list: æ¨æ–‡æ•°æ®åˆ—è¡¨

        Returns:
            list: åŒ…å«æ‘˜è¦çš„æ¨æ–‡åˆ—è¡¨
        """
        summarized_tweets = []

        for tweet in tweets_list:
            print(f"æ­£åœ¨ä¸º @{tweet.get('username', '')} çš„æ¨æ–‡ç”ŸæˆAIæ‘˜è¦...")

            # ç”Ÿæˆæ‘˜è¦
            summary = self.generate_summary(tweet)

            # å°†æ‘˜è¦æ·»åŠ åˆ°æ¨æ–‡æ•°æ®ä¸­
            tweet_with_summary = tweet.copy()
            tweet_with_summary['ai_summary'] = summary

            summarized_tweets.append(tweet_with_summary)

            # æ·»åŠ å»¶è¿Ÿé¿å…APIé™åˆ¶
            import time
            time.sleep(1)

        return summarized_tweets


App.py:


import os
import requests
import time
import signal
import sys
from datetime import datetime
from dotenv import load_dotenv

from database import TweetDatabase
from ai_summarizer import AISummarizer
from dingtalk_bot import dingtalk_bot


class TwitterAPIIOMonitor:
    def __init__(self):
        # åŠ è½½ç¯å¢ƒå˜é‡
        load_dotenv()

        self.api_key = os.getenv("TWITTER_API_KEY")
        if not self.api_key:
            raise ValueError("è¯·åœ¨.envé…ç½®TWITTER_API_KEY")

        self.base_url = "https://api.twitterapi.io"
        self.headers = {
            "X-API-Key": self.api_key,
            "Content-Type": "application/json"
        }

        # ğŸ”§ ä»ç¯å¢ƒå˜é‡è¯»å–å¤šä¸ªåšä¸»
        target_users_str = os.getenv("TARGET_USERS", "whyyoutouzhele")
        self.target_users = [user.strip() for user in target_users_str.split(",") if user.strip()]

        # ğŸ”§ ä»ç¯å¢ƒå˜é‡è¯»å–ç›‘æ§é…ç½®
        self.monitor_interval = int(os.getenv("MONITOR_INTERVAL", "300"))  # é»˜è®¤5åˆ†é’Ÿ
        # ğŸ”§ ä¿®æ”¹ï¼šé»˜è®¤åªè·å–5æ¡æœ€æ–°æ¨æ–‡ï¼ŒèŠ‚çœtoken
        self.max_tweets_per_request = int(os.getenv("MAX_TWEETS_PER_REQUEST", "5"))

        # æ§åˆ¶ç¨‹åºè¿è¡Œçš„æ ‡å¿—
        self.running = True

        # è®¾ç½®ä¿¡å·å¤„ç†ï¼Œæ”¯æŒä¼˜é›…é€€å‡º
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)

        self.db = TweetDatabase()  # åˆå§‹åŒ–æ•°æ®åº“æ¨¡å—
        self.ai_summarizer = AISummarizer()  # åˆå§‹åŒ–AIæ‘˜è¦æ¨¡å—

        print(f"ğŸ¯ ç›‘æ§ç›®æ ‡: {', '.join(['@' + user for user in self.target_users])}")
        print(f"â° ç›‘æ§é—´éš”: {self.monitor_interval} ç§’")
        print(f"ğŸ“Š æ¯æ¬¡è·å–: {self.max_tweets_per_request} æ¡æ¨æ–‡ (èŠ‚çœtokenæ¨¡å¼)")
        print(f"ğŸ’° é¢„è®¡æ¯å‘¨æœŸæ¶ˆè€—: {len(self.target_users) * 1} æ¬¡APIè°ƒç”¨")

    def signal_handler(self, signum, frame):
        """å¤„ç†é€€å‡ºä¿¡å·"""
        print(f"\nğŸ›‘ æ”¶åˆ°é€€å‡ºä¿¡å·ï¼Œæ­£åœ¨åœæ­¢ç›‘æ§...")
        self.running = False

    def get_latest_tweets(self, username, limit=None):
        """è·å–ç”¨æˆ·æœ€æ–°æ¨æ–‡"""
        if limit is None:
            limit = self.max_tweets_per_request

        endpoint = f"{self.base_url}/twitter/tweet/advanced_search"

        params = {
            "query": f"from:{username}",
            "queryType": "Latest",
            "limit": limit
        }

        try:
            print(f"ğŸ“¡ æ­£åœ¨è·å– @{username} çš„æœ€æ–° {limit} æ¡æ¨æ–‡...")
            resp = requests.get(endpoint, headers=self.headers, params=params, timeout=30)

            if resp.status_code != 200:
                print(f"âŒ è¯·æ±‚å¤±è´¥: {resp.status_code} - {resp.text}")
                return []

            data = resp.json()
            tweets = data.get("tweets", []) or data.get("data", [])

            print(f"âœ… æˆåŠŸè·å– @{username} çš„ {len(tweets)} æ¡æ¨æ–‡")
            return tweets

        except Exception as e:
            print(f"âŒ è·å– @{username} æœ€æ–°æ¨æ–‡å¤±è´¥: {e}")
            return []

    def format_tweet(self, tweet, username):
        """æ ‡å‡†åŒ–æ¨æ–‡"""
        tweet_id = tweet.get("id")
        text = tweet.get("text", "")

        # æ—¶é—´å¤„ç†
        created_at_raw = tweet.get('createdAt')
        created_at = created_at_raw

        if created_at_raw:
            try:
                # è§£ææ ¼å¼ï¼š'Sat Nov 22 04:00:00 +0000 2025'
                dt = datetime.strptime(created_at_raw, '%a %b %d %H:%M:%S %z %Y')
                created_at = dt.strftime("%Y-%m-%d %H:%M:%S")
            except Exception as e:
                try:
                    # å°è¯•ISOæ ¼å¼
                    dt = datetime.fromisoformat(created_at_raw.replace('Z', '+00:00'))
                    created_at = dt.strftime("%Y-%m-%d %H:%M:%S")
                except:
                    pass

        # äº’åŠ¨æ•°æ®
        likes = tweet.get('likeCount', 0) or tweet.get('favorite_count', 0)
        retweets = tweet.get('retweetCount', 0)
        replies = tweet.get('replyCount', 0)
        quotes = tweet.get('quoteCount', 0)
        views = tweet.get('viewCount', 0)

        return {
            "username": username,
            "tweet_id": tweet_id,
            "text": text,
            "created_at": created_at,
            "raw_created_at": created_at_raw,
            "likes": likes,
            "retweets": retweets,
            "replies": replies,
            "quotes": quotes,
            "views": views,
            "entities": tweet.get("entities", {}),
            "attachments": tweet.get("attachments", {}),
            "geo": tweet.get("geo", {}),
            "source": tweet.get("source"),
            "lang": tweet.get("lang"),
            "possibly_sensitive": tweet.get("possibly_sensitive", False),
            "public_metrics": {
                'like_count': likes,
                'retweet_count': retweets,
                'reply_count': replies,
                'quote_count': quotes,
                'view_count': views
            },
            "raw_tweet": tweet
        }

    def process_single_tweet(self, tweet_data):
        """å¤„ç†å•æ¡æ¨æ–‡ - ç”ŸæˆAIæ‘˜è¦å¹¶ç«‹å³æ¨é€"""
        print("\n" + "=" * 60)
        print("ğŸ”¥ æ•è·åˆ°æ–°æ¨æ–‡ï¼")
        print(f"ğŸ‘¤ ç”¨æˆ·: @{tweet_data['username']}")
        print(f"ğŸ• æ—¶é—´: {tweet_data['created_at']}")
        print(f"ğŸ“ å†…å®¹: {tweet_data['text'][:100]}{'...' if len(tweet_data['text']) > 100 else ''}")
        print(
            f"ğŸ“Š äº’åŠ¨: ğŸ‘ {tweet_data['likes']} | ğŸ”„ {tweet_data['retweets']} | ğŸ’¬ {tweet_data['replies']} | ğŸ‘ï¸ {tweet_data['views']}")

        # ç«‹å³ç”ŸæˆAIæ‘˜è¦
        print("ğŸ¤– æ­£åœ¨ç”ŸæˆAIæ‘˜è¦...")
        ai_summary = self.ai_summarizer.generate_summary(tweet_data)
        tweet_data['ai_summary'] = ai_summary

        print("ğŸ¤– AIæ‘˜è¦:")
        print(f"   {ai_summary}")
        print("=" * 60)

        # å†™å…¥æ•°æ®åº“
        self.db.insert_tweet(tweet_data)

        # ç«‹å³å‘é€é’‰é’‰é€šçŸ¥
        print("ğŸ“¤ æ­£åœ¨å‘é€é’‰é’‰é€šçŸ¥...")
        success = dingtalk_bot.send_tweet_notification(tweet_data)
        if success:
            print("âœ… é’‰é’‰é€šçŸ¥å‘é€æˆåŠŸ")
        else:
            print("âŒ é’‰é’‰é€šçŸ¥å‘é€å¤±è´¥")

        # æ·»åŠ å»¶è¿Ÿé¿å…é¢‘ç¹è¯·æ±‚
        time.sleep(2)

        return True

    def process_new_tweets(self, formatted_tweets):
        """å¤„ç†æ–°æ¨æ–‡ - é€æ¡å¤„ç†å¹¶ç«‹å³æ¨é€"""
        if not formatted_tweets:
            return 0

        print(f"ğŸ¤– å‘ç° {len(formatted_tweets)} æ¡æ–°æ¨æ–‡ï¼Œå¼€å§‹é€æ¡å¤„ç†...")

        processed_count = 0
        for tweet in formatted_tweets:
            if not self.running:
                break

            try:
                self.process_single_tweet(tweet)
                processed_count += 1
            except Exception as e:
                print(f"âŒ å¤„ç†æ¨æ–‡å¤±è´¥: {e}")
                # ç»§ç»­å¤„ç†ä¸‹ä¸€æ¡æ¨æ–‡
                continue

        return processed_count

    def monitor_single_cycle(self):
        """æ‰§è¡Œå•æ¬¡ç›‘æ§å¾ªç¯"""
        print(f"\nğŸ”„ [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] å¼€å§‹ç›‘æ§å¾ªç¯...")

        all_new_tweets = []
        total_checked = 0

        for username in self.target_users:
            if not self.running:
                break

            print(f"ğŸ” æ­£åœ¨æ£€æŸ¥ @{username} ...")
            tweets = self.get_latest_tweets(username)
            total_checked += len(tweets)

            new_tweets = []
            for tweet in tweets:
                if not self.running:
                    break

                tweet_id = tweet.get("id")
                if tweet_id and not self.db.tweet_exists(tweet_id):
                    formatted = self.format_tweet(tweet, username)
                    new_tweets.append(formatted)

            if new_tweets:
                print(f"âœ… @{username}: å‘ç° {len(new_tweets)} æ¡æ–°æ¨æ–‡")
                all_new_tweets.extend(new_tweets)
            else:
                print(f"â„¹ï¸  @{username}: æ²¡æœ‰æ–°æ¨æ–‡")

        # å¤„ç†æ‰€æœ‰æ–°æ¨æ–‡
        if all_new_tweets:
            processed_count = self.process_new_tweets(all_new_tweets)
            print(f"ğŸ‰ æœ¬è½®ç›‘æ§å®Œæˆ: æˆåŠŸå¤„ç† {processed_count}/{len(all_new_tweets)} æ¡æ–°æ¨æ–‡")
        else:
            print(f"ğŸ“­ æœ¬è½®ç›‘æ§å®Œæˆ: æ²¡æœ‰å‘ç°æ–°æ¨æ–‡ (æ£€æŸ¥äº† {total_checked} æ¡æ¨æ–‡)")

    def start_real_time_monitoring(self):
        """å¯åŠ¨å®æ—¶ç›‘æ§"""
        print("ğŸš€ å¯åŠ¨ Twitter å®æ—¶ç›‘æ§...")
        print("ğŸ’¡ æŒ‰ Ctrl+C åœæ­¢ç›‘æ§")

        cycle_count = 0

        while self.running:
            cycle_count += 1
            print(f"\n{'=' * 50}")
            print(f"ğŸ“ˆ ç›‘æ§å‘¨æœŸ #{cycle_count}")
            print(f"{'=' * 50}")

            try:
                self.monitor_single_cycle()
            except Exception as e:
                print(f"âŒ ç›‘æ§å‘¨æœŸæ‰§è¡Œå‡ºé”™: {e}")
                # ç»§ç»­è¿è¡Œï¼Œä¸é€€å‡º

            if not self.running:
                break

            # ç­‰å¾…ä¸‹ä¸€ä¸ªç›‘æ§å‘¨æœŸ
            print(f"\nâ³ ç­‰å¾… {self.monitor_interval} ç§’åç»§ç»­ç›‘æ§...")
            for i in range(self.monitor_interval):
                if not self.running:
                    break
                time.sleep(1)
                if i % 30 == 0 and i > 0:  # æ¯30ç§’æ‰“å°ä¸€æ¬¡ç­‰å¾…çŠ¶æ€
                    remaining = self.monitor_interval - i
                    print(f"  ç­‰å¾…ä¸­... {remaining} ç§’åç»§ç»­")

        print("\nğŸ›‘ ç›‘æ§å·²åœæ­¢")


def main():
    try:
        monitor = TwitterAPIIOMonitor()
        monitor.start_real_time_monitoring()
    except KeyboardInterrupt:
        print("\nğŸ‘‹ ç”¨æˆ·ä¸»åŠ¨åœæ­¢ç›‘æ§")
    except Exception as e:
        print(f"ğŸ’¥ ç¨‹åºè¿è¡Œå‡ºé”™: {e}")
    finally:
        print("ğŸ¯ ç›‘æ§ç¨‹åºå·²é€€å‡º")


if __name__ == "__main__":
    main()

database.pyï¼š

import os
import json
import mysql.connector
from mysql.connector import Error
from dotenv import load_dotenv


class TweetDatabase:
    def __init__(self):
        load_dotenv()

        self.host = os.getenv("MYSQL_HOST")
        self.user = os.getenv("MYSQL_USER")
        self.password = os.getenv("MYSQL_PASSWORD")
        self.database = os.getenv("MYSQL_DB")

        self.conn = None
        self.connect()
        self.create_table()

    def connect(self):
        try:
            self.conn = mysql.connector.connect(
                host=self.host,
                user=self.user,
                password=self.password,
                database=self.database
            )
            print("æ•°æ®åº“è¿æ¥æˆåŠŸ")
        except Error as e:
            print(f"æ•°æ®åº“è¿æ¥å¤±è´¥: {e}")
            raise e

    def create_table(self):
        create_table_sql = """
        CREATE TABLE IF NOT EXISTS tweets (
            tweet_id VARCHAR(30) PRIMARY KEY,
            username VARCHAR(255),
            text TEXT,
            source VARCHAR(255),
            retweetCount INT DEFAULT 0,
            replyCount INT DEFAULT 0,
            likeCount INT DEFAULT 0,
            quoteCount INT DEFAULT 0,
            viewCount INT DEFAULT 0,
            createdAt VARCHAR(255),
            lang VARCHAR(20),
            bookmarkCount INT DEFAULT 0,
            isReply BOOLEAN,
            inReplyToId VARCHAR(30),
            conversationId VARCHAR(30),
            displayTextRange TEXT,
            inReplyToUserId VARCHAR(30),
            inReplyToUsername VARCHAR(255),
            author JSON,
            raw_tweet JSON
        );
        """
        cursor = self.conn.cursor()
        cursor.execute(create_table_sql)
        cursor.close()
        self.conn.commit()

    def tweet_exists(self, tweet_id):
        """åˆ¤æ–­è¯¥æ¨æ–‡æ˜¯å¦å·²å­˜åœ¨"""
        sql = "SELECT tweet_id FROM tweets WHERE tweet_id = %s LIMIT 1"
        cursor = self.conn.cursor()
        cursor.execute(sql, (tweet_id,))
        result = cursor.fetchone()
        cursor.close()
        return result is not None

    def insert_tweet(self, tweet: dict):
        """æ’å…¥æ–°æ¨æ–‡"""
        sql = """
        INSERT INTO tweets (
            tweet_id, username, text, source,
            retweetCount, replyCount, likeCount, quoteCount, viewCount,
            createdAt, lang, bookmarkCount, isReply,
            inReplyToId, conversationId, displayTextRange,
            inReplyToUserId, inReplyToUsername, author, raw_tweet
        )
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """

        values = (
            tweet["tweet_id"],
            tweet["username"],
            tweet["text"],
            tweet["source"],
            tweet.get("retweetCount", 0),
            tweet.get("replyCount", 0),
            tweet.get("likeCount", 0),
            tweet.get("quoteCount", 0),
            tweet.get("viewCount", 0),
            tweet.get("createdAt"),
            tweet.get("lang"),
            tweet.get("bookmarkCount", 0),
            tweet.get("isReply", False),
            tweet.get("inReplyToId"),
            tweet.get("conversationId"),
            json.dumps(tweet.get("displayTextRange"), ensure_ascii=False),
            tweet.get("inReplyToUserId"),
            tweet.get("inReplyToUsername"),
            json.dumps(tweet.get("author"), ensure_ascii=False),
            json.dumps(tweet.get("raw_tweet"), ensure_ascii=False)
        )

        cursor = self.conn.cursor()
        try:
            cursor.execute(sql, values)
            self.conn.commit()
            print(f"æ•°æ®åº“æ’å…¥æˆåŠŸ: tweet_id={tweet['tweet_id']}")
        except Error as e:
            print(f"æ’å…¥å¤±è´¥: {e}")
        finally:
            cursor.close()


dingtalk.pyï¼š

import os
import requests
import json
import time
import hmac
import hashlib
import base64
from urllib.parse import quote_plus
from dotenv import load_dotenv


class DingTalkBot:
    def __init__(self):
        # åŠ è½½ç¯å¢ƒå˜é‡
        load_dotenv()

        # ä»ç¯å¢ƒå˜é‡è·å–é’‰é’‰æœºå™¨äººé…ç½®
        self.access_token = os.getenv('DINGTALK_ACCESS_TOKEN')
        self.secret = os.getenv('DINGTALK_SECRET',
                                'SEC1e2b648e1af505a61e4b6f0e357b2be254906db38dfe28d712d2f8d172d9f161')

        if not self.access_token:
            raise ValueError("è¯·åœ¨.envæ–‡ä»¶ä¸­é…ç½®DINGTALK_ACCESS_TOKEN")

    def generate_signature(self):
        """ç”Ÿæˆé’‰é’‰æœºå™¨äººç­¾å"""
        timestamp = str(round(time.time() * 1000))
        string_to_sign = f'{timestamp}\n{self.secret}'

        # ä½¿ç”¨HMAC-SHA256ç®—æ³•è®¡ç®—ç­¾å
        hmac_code = hmac.new(
            self.secret.encode('utf-8'),
            string_to_sign.encode('utf-8'),
            hashlib.sha256
        ).digest()

        # Base64ç¼–ç å¹¶è¿›è¡ŒURLç¼–ç 
        sign = quote_plus(base64.b64encode(hmac_code))
        return timestamp, sign

    def get_webhook_url(self):
        """è·å–å¸¦ç­¾åçš„å®Œæ•´Webhook URL"""
        timestamp, sign = self.generate_signature()
        webhook_url = f'https://oapi.dingtalk.com/robot/send?access_token={self.access_token}&timestamp={timestamp}&sign={sign}'
        return webhook_url

    def send_markdown_message(self, title, text, at_mobiles=None, is_at_all=False):
        """
        å‘é€Markdownæ ¼å¼æ¶ˆæ¯åˆ°é’‰é’‰ç¾¤
        """
        headers = {
            'Content-Type': 'application/json'
        }

        # è·å–å¸¦ç­¾åçš„Webhook URL
        webhook_url = self.get_webhook_url()

        # æ„å»ºæ¶ˆæ¯æ•°æ®
        data = {
            "msgtype": "markdown",
            "markdown": {
                "title": title,
                "text": text
            },
            "at": {
                "atMobiles": at_mobiles or [],
                "isAtAll": is_at_all
            }
        }

        try:
            response = requests.post(
                webhook_url,
                headers=headers,
                data=json.dumps(data),
                timeout=10
            )

            if response.status_code == 200:
                result = response.json()
                if result.get('errcode') == 0:
                    return True
                else:
                    print(f"âŒ é’‰é’‰æ¶ˆæ¯å‘é€å¤±è´¥: {result.get('errmsg')}")
                    return False
            else:
                print(f"âŒ é’‰é’‰APIè¯·æ±‚å¤±è´¥: {response.status_code}")
                return False

        except Exception as e:
            print(f"âŒ é’‰é’‰æ¶ˆæ¯å‘é€å¼‚å¸¸: {e}")
            return False

    def format_tweet_message(self, tweet_data):
        """
        æ ¼å¼åŒ–æ¨æ–‡æ•°æ®ä¸ºé’‰é’‰æ¶ˆæ¯
        """
        username = tweet_data.get('username', '')
        created_at = tweet_data.get('created_at', '')
        text = tweet_data.get('text', '')
        likes = tweet_data.get('likes', 0)
        retweets = tweet_data.get('retweets', 0)
        replies = tweet_data.get('replies', 0)
        views = tweet_data.get('views', 0)
        ai_summary = tweet_data.get('ai_summary', '')

        # æ„å»ºæ ‡é¢˜
        title = f"ğŸ”¥ æ–°æ¨æ–‡æé†’ - @{username}"

        # æ„å»ºMarkdownå†…å®¹
        text_content = f"""## ğŸ”¥ æ•è·åˆ°æ–°æ¨æ–‡ï¼

**ğŸ‘¤ ç”¨æˆ·:** @{username}
**ğŸ• æ—¶é—´:** {created_at}

**ğŸ“ å†…å®¹:**
{text}

**ğŸ“Š äº’åŠ¨æ•°æ®:**
- ğŸ‘ ç‚¹èµ: {likes}
- ğŸ”„ è½¬æ¨: {retweets}
- ğŸ’¬ å›å¤: {replies}
- ğŸ‘ï¸ æµè§ˆ: {views}

**ğŸ¤– AIæ‘˜è¦:**
{ai_summary}

---
*æ¥è‡ª Twitter å®æ—¶ç›‘æ§æœºå™¨äºº*"""

        return title, text_content

    def send_tweet_notification(self, tweet_data):
        """
        å‘é€æ¨æ–‡é€šçŸ¥åˆ°é’‰é’‰
        """
        title, content = self.format_tweet_message(tweet_data)
        return self.send_markdown_message(title, content)


# å•ä¾‹æ¨¡å¼ï¼Œä¾¿äºå…¨å±€ä½¿ç”¨
dingtalk_bot = DingTalkBot()


.envæ–‡ä»¶ï¼š

MYSQL_HOST=localhost
MYSQL_USER=root
MYSQL_PASSWORD="Wlk8916!$#"
MYSQL_DB=æ¨ç‰¹ç›‘æ§_æ‰‹æ“ç‰ˆ

TWITTER_API_KEY=747cf17386ab4fcd8a8f4591e6109f43
DASHSCOPE_API_KEY=sk-0501148d869d404db92a60b29b6aa11c
DINGTALK_ACCESS_TOKEN=194fec64adf35c6d55de2454dfaa8be2501a6578abe30a4f005dd4b16048ac14

TARGET_USERS=whyyoutouzhele,wangzhian8848,tankman2002,xiaojingcanxue
MONITOR_INTERVAL=300
MAX_TWEETS_PER_REQUEST=5